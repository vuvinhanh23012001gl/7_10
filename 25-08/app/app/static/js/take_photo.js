//Phan nay se bat lai sau khi hoan thanh
let Limit_x = 0;
let Limit_y = 0;
let Limit_z = 0;
let Limit_k = 0;

const videoSocket = io("/video");
videoSocket.on("camera_frame", function (data) {
    document.getElementById("cam_feed").src = "data:image/jpeg;base64," + data.image;
});

window.addEventListener('beforeunload', function() {
    navigator.sendBeacon('/api_new_model/stop-video'); 
});

const logSocket = io("/log");
logSocket.on("log_message", function (data) {
    const logBox = document.getElementById("summaryBox");
    if (logBox) {
        logBox.value += data.log_training + "\n";
        logBox.scrollTop = logBox.scrollHeight;
    } else {
        console.warn("Kh√¥ng t√¨m th·∫•y textarea log");
    }
});
logSocket.on("log_message_product", function (data) {
    const textarea = document.getElementById('infoBox');  
    console.log(data);
    if (textarea) {
        let output = "";
        data = data.manage_product_type;  // ‚¨ÖÔ∏è ƒê√∫ng
        for (const key in data) {
            const type = data[key];
            output += `üîπ ID Lo·∫°i: ${type.type_id}\n`;
            output += `üì¶ T√™n lo·∫°i: ${type.type_name}\n`;
            output += `üìå S·ªë ƒëi·ªÉm ki·ªÉm tra: ${type.point_check.length}\n`;
            type.point_check.forEach((point, idx) => {
                output += `   ‚ñ∂Ô∏è ƒêi·ªÉm ${idx + 1}: x=${point.x}, y=${point.y}, z=${point.z}, brightness=${point.brightness}\n`;
            });
            output += '\n'; 
        }
        textarea.value = output;
        textarea.scrollTop = textarea.scrollHeight;
    } else {
        console.warn("Kh√¥ng t√¨m th·∫•y textarea log");
    }
});

let isReadonly = null; // tr·∫°ng th√°i hi·ªán t·∫°i
document.getElementById("btn_save_limit").addEventListener("click", function (event) {
    event.preventDefault();
    let inputs = document.querySelectorAll("#box-limmit input");

    if (!isReadonly) {
        // Ch·∫ø ƒë·ªô L∆∞u ‚Üí ki·ªÉm tra c√≥ nh·∫≠p ch∆∞a
        let valid = true;
        inputs.forEach(input => {
            if (input.value.trim() === "") {
                valid = false;
                input.style.border = "2px solid red";
            } else {
                input.style.border = "";
            }
        });

        if (!valid) {
            alert("‚ö†Ô∏è Vui l√≤ng nh·∫≠p ƒë·ªß gi·ªõi h·∫°n X, Y, Z,K!");
            return;
        }

        // N·∫øu h·ª£p l·ªá th√¨ set readonly
        inputs.forEach(input => input.readOnly = true);
        this.innerText = "Ch·ªânh s·ª≠a gi·ªõi h·∫°n"; // ƒë·ªïi t√™n n√∫t
        isReadonly = true;
        // L·∫•y gi√° tr·ªã ƒë·ªÉ x·ª≠ l√Ω
        let limit_x = document.querySelector("input[name=limit_x]").value;
        let limit_y = document.querySelector("input[name=limit_y]").value;
        let limit_z = document.querySelector("input[name=limit_z]").value;
        let limit_k = document.querySelector("input[name=limit_k]").value;
        if (limit_x < 0  ||  limit_y< 0 || limit_z < 0 || limit_k < 0)
        {   
            document.querySelector("input[name=limit_x]").value = 0;
            document.querySelector("input[name=limit_y]").value = 0;
            document.querySelector("input[name=limit_z]").value = 0;
            document.querySelector("input[name=limit_k]").value = 0;
            alert("‚ö†Ô∏è Kh√¥ng ƒë∆∞·ª£c c√†i gi·ªõi h·∫°n x,y,z,k nh·ªè h∆°n 0");
            return;
        }
          Limit_x = limit_x;
          Limit_y = limit_y;
          Limit_z = limit_z;
          Limit_k = limit_k;
          console.log("ƒë√£ thay ƒë·ªïi Limit");
          console.log("ƒê√£ l∆∞u:", limit_x, limit_y, limit_z,limit_k);
    } else {
        // Ch·∫ø ƒë·ªô Ch·ªânh s·ª≠a ‚Üí b·ªè readonly
        inputs.forEach(input => input.readOnly = false);
        this.innerText = "L∆∞u gi·ªõi h·∫°n";
        isReadonly = false;
    }
});


let selectedPointInputs = null;
let selectedPointIndex = null;
document.querySelector('form').addEventListener('submit', function(event) {
  event.preventDefault();  // NgƒÉn reload

  const form = event.target;
  const deviceIdInput = form.querySelector('input[name="deviceId"]');   
  const deviceNameInput = form.querySelector('input[name="deviceName"]');
  const numberTrainningInput = form.querySelector('input[name="number_trainings"]');   
  const shifXInput = form.querySelector('input[name="shif_x"]');
  const shifYInput = form.querySelector('input[name="shif_y"]');
  const shifZInput = form.querySelector('input[name="shif_z"]');

  const deviceId = parseInt(deviceIdInput.value, 10);
  const deviceName = deviceNameInput.value.trim();
  const Training = parseInt(numberTrainningInput.value,10);
  const shifX = parseFloat(shifXInput.value);
  const shifY = parseFloat(shifYInput.value);
  const shifZ = parseFloat(shifZInput.value);
  
  if (isNaN(deviceId) || deviceId < 0) {
    alert('‚ùå ID thi·∫øt b·ªã ph·∫£i l√† s·ªë l·ªõn h∆°n ho·∫∑c b·∫±ng 0');
    deviceIdInput.focus();
    return;
  }
  if (isNaN(Training) || Training < 1) {
    alert('‚ùå S·ªë l·∫ßn training ph·∫£i l√† s·ªë l·ªõn h∆°n ho·∫∑c b·∫±ng 1');
    numberTrainningInput.focus();
    return;
  }

  if (/\s/.test(deviceName) || deviceName === '') {
    alert('‚ùå T√™n thi·∫øt b·ªã kh√¥ng ƒë∆∞·ª£c ch·ª©a kho·∫£ng tr·∫Øng v√† kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng');
    deviceNameInput.focus();
    return;
  }

  const shifts = [
    {value: shifX, name: 'Di chuy·ªÉn theo tr·ª•c x', input: shifXInput},
    {value: shifY, name: 'Di chuy·ªÉn theo tr·ª•c y', input: shifYInput},
    {value: shifZ, name: 'Di chuy·ªÉn theo tr·ª•c z', input: shifZInput},
  ];

  for (const shift of shifts) {
    if (isNaN(shift.value) || shift.value <= 0 || shift.value >= 10) {
      alert(`‚ùå Gi√° tr·ªã ${shift.name} ph·∫£i l·ªõn h∆°n 0 v√† nh·ªè h∆°n 10`);
      shift.input.focus();
      return;
    }
  }

  const pointsContainer = document.getElementById('pointsContainer');
  const pointGroups = pointsContainer.querySelectorAll('.point-group');

  for (let i = 0; i < pointGroups.length; i++) {
    const group = pointGroups[i];
    const idx = i + 1;

    const inputX = group.querySelector('input[name="point_x[]"]');
    const inputY = group.querySelector('input[name="point_y[]"]');
    const inputZ = group.querySelector('input[name="point_z[]"]');
    const inputK = group.querySelector('input[name="point_k[]"]');

    if (!inputX || !inputY || !inputZ || !inputK) {
      alert(`‚ùå ƒêi·ªÉm d·∫ßu ${idx} thi·∫øu tr∆∞·ªùng d·ªØ li·ªáu`);
      return;
    }

    const x = parseFloat(inputX.value);
    const y = parseFloat(inputY.value);
    const z = parseFloat(inputZ.value);
    const k = parseFloat(inputK.value);

    const errorMsg = validatePoint(idx, x, y, z, k);
    if (errorMsg) {
      alert(errorMsg);
      inputX.focus();
      return;
    }
  }

  // ‚úÖ N·∫øu m·ªçi th·ª© ƒë·ªÅu OK ‚Üí g·ª≠i form b·∫±ng fetch
  const formData = new FormData(form);

  fetch('/api_new_model/submit', {
    method: 'POST',
    body: formData
  })
  .then(res => res.text())
  .then(data => {
    console.log("‚úÖ Server tr·∫£ v·ªÅ:", data);
    console.log("‚úÖ G·ª≠i form th√†nh c√¥ng!");
    // form.reset(); // N·∫øu mu·ªën x√≥a d·ªØ li·ªáu form sau khi g·ª≠i
  })
  .catch(err => {
    console.error("‚ùå L·ªói khi g·ª≠i form:", err);
    alert("‚ùå G·ª≠i form th·∫•t b·∫°i.");
  });
   // tao ra nut nhan replay
  const replay_run = document.getElementById("replay-run");
  replay_run.style.display = "block";

});

function addPoint() {
  if (isReadonly == null){
    alert("H√£y nh·∫≠p gi·ªõi h·∫°n x y z k");
    return;
  }
  console.log("Gi·ªõi h·∫°n x y z k ",Limit_x,Limit_y,Limit_z,Limit_k);
  const container = document.getElementById('pointsContainer');
  const currentCount = container.querySelectorAll('.point-group').length + 1;

  const group = document.createElement('div');
  group.classList.add('point-group');

  const labelLine = document.createElement('div');
  labelLine.classList.add('point-label');
  labelLine.textContent = `ƒêi·ªÉm d·∫ßu ${currentCount}`;
  group.appendChild(labelLine);

  const inputsRow = document.createElement('div');
  inputsRow.classList.add('inputs-row');

  const inputs = {}; // l∆∞u input theo t√™n

  ['X', 'Y', 'Z', 'K'].forEach(letter => {
    const label = document.createElement('label');
    label.textContent = letter;

    const input = document.createElement('input');
    input.type = 'number'; // Ch·ªâ cho nh·∫≠p s·ªë
    input.required = true; // B·∫Øt bu·ªôc nh·∫≠p
    input.min = 0; // Gi√° tr·ªã nh·ªè nh·∫•t
    input.name = `point_${letter.toLowerCase()}[]`;

    inputs[letter] = input;

    label.appendChild(input);
    inputsRow.appendChild(label);
  });

  // T·∫°o 3 n√∫t ‚Äî GI·ªÆ NGUY√äN CLASS b·∫°n ƒë√£ d√πng
  const btnStart = document.createElement('button');
  btnStart.type = 'button';
  btnStart.textContent = 'Start';
  btnStart.classList.add('btn', 'btn-sm', 'btn-primary');
  btnStart.style.marginLeft = '15px';
  btnStart.addEventListener('click', () => handleStart(currentCount, inputs));

  const btnSelect = document.createElement('button');
  btnSelect.type = 'button';
  btnSelect.textContent = 'Ch·ªçn';
  btnSelect.classList.add('btn', 'btn-sm', 'btn-primary');
  btnSelect.style.marginLeft = '10px';
  btnSelect.addEventListener('click', () => handleSelect(currentCount, inputs));

  const btnSave = document.createElement('button');
  btnSave.type = 'button';
  btnSave.textContent = 'Save';
  btnSave.classList.add('btn', 'btn-sm', 'btn-primary');
  btnSave.style.marginLeft = '10px';
  btnSave.addEventListener('click', () => handleSave(currentCount, inputs, btnSave));

  const btnErase = document.createElement('button');
  btnErase.type = 'button';
  btnErase.textContent = 'X√≥a';
  btnErase.classList.add('btn', 'btn-sm', 'btn-primary','btn-erase');
  btnErase.style.marginLeft = '10px';
  btnErase.addEventListener('click', () => handleErase(group));

  // Th√™m n√∫t v√†o d√≤ng
  inputsRow.appendChild(btnStart);
  inputsRow.appendChild(btnSelect);
  inputsRow.appendChild(btnSave);
  inputsRow.appendChild(btnErase);
  group.appendChild(inputsRow);
  container.appendChild(group);
}
function handleErase(group) {
  if (group && group.parentNode) {
    group.remove();
    // Sau khi x√≥a, c·∫≠p nh·∫≠t l·∫°i s·ªë th·ª© t·ª± c√°c label
    const groups = document.querySelectorAll('#pointsContainer .point-group');
    groups.forEach((g, i) => {
      const label = g.querySelector('.point-label');
      if (label) {
        label.textContent = `ƒêi·ªÉm d·∫ßu ${i + 1}`;
      }
    });

    console.log('üóëÔ∏è ƒê√£ x√≥a group v√† c·∫≠p nh·∫≠t l·∫°i th·ª© t·ª±.');
  }
}
function handleStart(index, inputs) {
  // L·∫•y gi√° tr·ªã t·ª´ c√°c input
  const x = parseFloat(inputs.X.value);
  const y = parseFloat(inputs.Y.value);
  const z = parseFloat(inputs.Z.value);
  const brightness = parseFloat(inputs.K.value); // K l√† ƒë·ªô s√°ng

  const errorMsg = validatePoint(index, x, y, z, brightness);
  if (errorMsg) {
    alert(errorMsg);
    return;
  }

  // ‚úÖ G·ª≠i d·ªØ li·ªáu t·ªõi server
  fetch('/api_new_model/run_point', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      x: x,
      y: y,
      z: z,
      brightness: brightness
    })
  })
    .then(response => response.json())
    .then(data => {
      console.log("Tr·∫°ng th√°i:",data.message)
      console.log(`‚úÖ ƒê√£ g·ª≠i ƒëi·ªÉm ${index} ƒë·∫øn thi·∫øt b·ªã. Ph·∫£n h·ªìi: ${data.message}`);
    })
    .catch(error => {
      console.error('L·ªói khi g·ª≠i ƒëi·ªÉm:', error);
      alert('‚ùå G·ª≠i d·ªØ li·ªáu th·∫•t b·∫°i.');
    });
}

function handleSelect(pointIndex, inputs) {
  console.log(`‚úî Ch·ªçn t·ªça ƒë·ªô ƒëi·ªÉm d·∫ßu #${pointIndex}`);
  selectedPointInputs = inputs;
  selectedPointIndex = pointIndex;
  alert(`üéØ ƒê√£ ch·ªçn ƒëi·ªÉm d·∫ßu #${pointIndex} ƒë·ªÉ ƒëi·ªÅu ch·ªânh`);
}

function handleSave(index, inputs, btnSave) {
  const x = parseFloat(inputs.X.value);
  const y = parseFloat(inputs.Y.value);
  const z = parseFloat(inputs.Z.value);
  const brightness = parseFloat(inputs.K.value);

  const errorMsg = validatePoint(index, x, y, z, brightness);
  if (errorMsg) {
    alert(errorMsg);
    return; // d·ª´ng x·ª≠ l√Ω n·∫øu l·ªói
  }

  const isReadOnly = inputs.X.readOnly;

  if (!isReadOnly) {
    // Kh√≥a readonly, ƒë·ªïi n√∫t th√†nh "H·ªßy"
    inputs.X.readOnly = true;
    inputs.Y.readOnly = true;
    inputs.Z.readOnly = true;
    inputs.K.readOnly = true;

    btnSave.textContent = 'H·ªßy';
    btnSave.classList.remove('btn-primary');
    btnSave.classList.add('btn-danger');

    console.log(`üîí ƒê√£ kh√≥a ch·ªânh s·ª≠a cho ƒëi·ªÉm d·∫ßu #${index}`);
  } else {
    // M·ªü kh√≥a, ƒë·ªïi n√∫t v·ªÅ "Save"
    inputs.X.readOnly = false;
    inputs.Y.readOnly = false;
    inputs.Z.readOnly = false;
    inputs.K.readOnly = false;

    btnSave.textContent = 'Save';
    btnSave.classList.remove('btn-danger');
    btnSave.classList.add('btn-primary');

    console.log(`‚úèÔ∏è Cho ph√©p ch·ªânh s·ª≠a l·∫°i ƒëi·ªÉm d·∫ßu #${index}`);
  }
}

function validatePoint(index, x, y, z, brightness) {
  if (isNaN(x) || isNaN(y) || isNaN(z) || isNaN(brightness)) {
    return `‚ùå ƒêi·ªÉm d·∫ßu ${index}: C√°c gi√° tr·ªã X, Y, Z, K ph·∫£i l√† s·ªë h·ª£p l·ªá v√† kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng`;
  }
  if (x < 0 || y < 0 || z < 0 || brightness < 0) {
    return `‚ùå ƒêi·ªÉm d·∫ßu ${index}: Gi√° tr·ªã X, Y, Z, K ph·∫£i l·ªõn h∆°n ho·∫∑c b·∫±ng 0`;
  }
  if (x > Limit_x) {
    return `‚ùå ƒêi·ªÉm d·∫ßu ${index}: Gi√° tr·ªã X ph·∫£i nh·ªè h∆°n ho·∫∑c b·∫±ng ${Limit_x}`;
  }
  if (y > Limit_y) {
    return `‚ùå ƒêi·ªÉm d·∫ßu ${index}: Gi√° tr·ªã Y ph·∫£i nh·ªè h∆°n ho·∫∑c b·∫±ng ${Limit_y}`;
  }
  if (z > Limit_z) {
    return `‚ùå ƒêi·ªÉm d·∫ßu ${index}: Gi√° tr·ªã Z ph·∫£i nh·ªè h∆°n ho·∫∑c b·∫±ng ${Limit_z}`;
  }
  if (brightness > Limit_k) {
    return `‚ùå ƒêi·ªÉm d·∫ßu ${index}: Gi√° tr·ªã √°nh s√°ng (K) ph·∫£i nh·ªè h∆°n ho·∫∑c b·∫±ng ${Limit_k}`;
  }
  return null; // kh√¥ng l·ªói
}
document.querySelector('.btn_inc_dec').addEventListener('click', function (e) {
  if (e.target.id === "case_specail") return;
  if (!e.target.matches('button')) return;
  if (e.target.id === "replay-run"){
      fetch('/api_new_model/replay')
      .then(response => response.json())
      .then(data => {
        console.log('üì• Server tr·∫£ v·ªÅ:', data);
      })
      .catch(err => {
        console.error('‚ùå L·ªói khi g·ª≠i GET:', err);
      });
    return;
  }
  if (!selectedPointInputs) {
    alert('‚ùó Vui l√≤ng ch·ªçn m·ªôt ƒëi·ªÉm d·∫ßu tr∆∞·ªõc');
    return;
  }

  const getInt = (input) => parseInt(input.value) || 0;

  const updateAndSend = () => {
    const x = getInt(selectedPointInputs.X);
    const y = getInt(selectedPointInputs.Y);
    const z = getInt(selectedPointInputs.Z);
    const k = parseFloat(selectedPointInputs.K.value) || 0;

    const error = validatePoint(selectedPointIndex, x, y, z, k);
    if (error) {
      alert(error);
      return;
    }

    fetch('/api_new_model/run_point', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        x: x,
        y: y,
        z: z,
        brightness: k
      })
    })
      .then(res => res.json())
      .then(data => {
         console.log("Tr·∫°ng th√°i:",data.message)
         console.log(`‚úÖ ƒê√£ g·ª≠i ƒëi·ªÉm ${selectedPointIndex} ƒë·∫øn thi·∫øt b·ªã. Ph·∫£n h·ªìi: ${data.message}`);
      })
  };

  const action = e.target.textContent;

  if (action.includes('TƒÉng X')) {
    const newVal = getInt(selectedPointInputs.X) + 1;
    if (newVal >= 0 && newVal <= Limit_x) {
      selectedPointInputs.X.value = newVal;
      updateAndSend();
    } else {
      alert(`Gi√° tr·ªã X ph·∫£i >= 0 v√† <= ${Limit_x}`);
    }
  } else if (action.includes('Gi·∫£m X')) {
    const newVal = getInt(selectedPointInputs.X) - 1;
    if (newVal >= 0 && newVal <= Limit_x) {
      selectedPointInputs.X.value = newVal;
      updateAndSend();
    } else {
      alert(`Gi√° tr·ªã X ph·∫£i >= 0 v√† <= ${Limit_x}`);
    }
  } else if (action.includes('TƒÉng Y')) {
    const newVal = getInt(selectedPointInputs.Y) + 1;
    if (newVal >= 0 && newVal <= Limit_y) {
      selectedPointInputs.Y.value = newVal;
      updateAndSend();
    } else {
      alert(`Gi√° tr·ªã Y ph·∫£i >= 0 v√† <= ${Limit_y}`);
    }
  } else if (action.includes('Gi·∫£m Y')) {
    const newVal = getInt(selectedPointInputs.Y) - 1;
    if (newVal >= 0 && newVal <= Limit_y) {
      selectedPointInputs.Y.value = newVal;
      updateAndSend();
    } else {
      alert(`Gi√° tr·ªã Y ph·∫£i >= 0 v√† <= ${Limit_y}`);
    }
  } else if (action.includes('TƒÉng Z')) {
    const newVal = getInt(selectedPointInputs.Z) + 1;
    if (newVal >= 0 && newVal <= Limit_z) {
      selectedPointInputs.Z.value = newVal;
      updateAndSend();
    } else {
      alert(`Gi√° tr·ªã Z ph·∫£i >= 0 v√† <=${Limit_z}`);
    }
  } else if (action.includes('Gi·∫£m Z')) {
    const newVal = getInt(selectedPointInputs.Z) - 1;
    if (newVal >= 0 && newVal <= Limit_z) {
      selectedPointInputs.Z.value = newVal;
      updateAndSend();
    } else {
      alert(`Gi√° tr·ªã Z ph·∫£i >= 0 v√† <= ${Limit_z}`);
    }
  } 
  else if (action.includes('Gi·∫£m K')) {
    const newVal = getInt(selectedPointInputs.K) - 1;
    if (newVal >= 0 && newVal <= Limit_k) {
      selectedPointInputs.K.value = newVal;
      updateAndSend();
    } else {
      alert(`Gi√° tr·ªã K ph·∫£i >= 0 v√† <= ${Limit_k}`);
    }
  } 
  else if (action.includes('TƒÉng K')) {
    const newVal = getInt(selectedPointInputs.K) + 1;
    if (newVal >= 0 && newVal <= Limit_k) {
      selectedPointInputs.K.value = newVal;
      updateAndSend();
    } else {
      alert(`Gi√° tr·ªã K ph·∫£i >= 0 v√† <= ${Limit_k}`);
    }
  } 
});
        // Get product infomation  --------------------------------------------

function sendAllPoints() {
  const container = document.getElementById('pointsContainer');
  const groups = container.querySelectorAll('.point-group');

  const points = [];

  for (let group of groups) {
   const x = parseFloat(group.querySelector('input[name="point_x[]"]').value);
   const y = parseFloat(group.querySelector('input[name="point_y[]"]').value);
   const z = parseFloat(group.querySelector('input[name="point_z[]"]').value);
   const k = parseFloat(group.querySelector('input[name="point_k[]"]').value);

    points.push({ x, y, z, k });
  }

  fetch('/api_new_model/run_all_points', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ points })
  })
  .then(res => res.json())
  .then(data => {
    console.log("‚úÖ G·ª≠i th√†nh c√¥ng: " + data.message);
  })
  .catch(err => {
    console.error('L·ªói khi g·ª≠i ƒëi·ªÉm d·∫ßu:', err);
  });
}
//check connect --------------------------------------------
function isConect(isconect){
    const ob_status_connect = document.getElementById("header-show-status");
    const ob_cir_status_connect = document.getElementById("header-show-circle");  
    if (isconect) {
        ob_cir_status_connect.classList.remove("disconnect");
        ob_cir_status_connect.classList.add("connecting");
        ob_status_connect.innerText = "";
        ob_status_connect.innerText = "ƒêang k·∫øt n·ªëi";
        } else {
        ob_cir_status_connect.classList.add("disconnect");
        ob_cir_status_connect.classList.remove("connecting");
        ob_status_connect.innerText = "";
        ob_status_connect.innerText = "M·∫•t k·∫øt n·ªëi";
    }
}
// //ham nay se bat lai sau khi hoan thien
// function fetchStatusConect() {
//     fetch('/api_new_model/get_status?param1=status_connect')
//         .then(response => {
//             if (!response.ok) {
//                 throw new Error('Network response was not ok: ' + response.statusText);
//             }
//             return response.text(); 
//         })
//         .then(data => {
//             const statusCode = parseInt(data.trim()); 
//             console.log('Status received:', statusCode);

//             // X·ª≠ l√Ω t√πy theo gi√° tr·ªã tr·∫£ v·ªÅ
//             switch (statusCode) {
//                 case 0:
//                     isConect(0);
//                     break;
//                 case 1:
//                     isConect(1);
//                     break;
//                 default:
//                     console.log('Tr·∫°ng th√°i kh√¥ng x√°c ƒë·ªãnh');
//             }
//         })
//         .catch(error => {
//             console.error('Fetch error:', error);
//         });
// }
// fetchStatusConect();
// setInterval(fetchStatusConect, 1000);
//--------------------------------------------
  function showExitModal() {
    const modal = document.getElementById('exit-modal');
    if (modal) modal.style.display = 'flex';
  }

  function hideExitModal() {
    const modal = document.getElementById('exit-modal');
    if (modal) modal.style.display = 'none';
  }

function confirmExit() {
       fetch('/api_new_model/exit-training')
      .then(response => {
          if (response.redirected) {
              // N·∫øu Flask redirect tr·ª±c ti·∫øp
              window.location.href = response.url;
          } else {
              // N·∫øu Flask tr·∫£ v·ªÅ JSON (n·∫øu b·∫°n thay ƒë·ªïi API)
              response.json().then(data => {
                  window.location.href = data.redirect_url;
              });
          }
      });
}
